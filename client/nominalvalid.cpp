/* Steshenko A.S. IVT-265 */

#include "nominalvalid.h"

NominalValid::NominalValid(QObject *parent)
	: QValidator(parent)
{

}

NominalValid::NominalValid()
	: QValidator(NULL)
{
	
}

NominalValid::~NominalValid()
{

}

/*Функция поиска пробела в строке:
*\param  [in]  str - строка, содержащая номинал
*\return-controlle - индекс первого пробела, введенного в строку номинала
*/
int Sydia(QString str)
{
	int controlle;//индекс первого пробела, введенного в строку номинала
	controlle=str.indexOf(' ');//непосредственно поиск пробела
	return controlle;//возвращаем индекс первого пробела
}

/*Функция проверки ввода цифр ДО пробела:
*\param [in] str  - строка, содержащая номинал
*\param [in]   i  - индекс первого пробела
*\return-DigitalF - флаг, показывающий, введены ли только цифры до пробела
*/
bool Digitall(QString str,int i)
{
	i=Sydia(str);//находим индекс первого пробела
	int j;//индекс символа строки
	bool DigitalF=true;//флаг, показывающий, введены ли только цифры до пробела
	//Если позиция пробела больше нуля
	if(i>0)
	{
		for(j=0;j<i;j++)//,то пробегаем по строке до индекса пробела
		{
			//и проверяем, является ли каждый символ цифрой и на той ли он позиции
			if((!str[j].isDigit()) && str.length()>j)
			{
				DigitalF=false;//если хотя бы один символ не цифра, то возвращаем ложь
			}
		}
	}
	//иначе если пробел еще не введен,
	else if(i == -1)
	{
		for(j=0;j<30;j++)//то пробегаем по всей длинне строки номинала
		{
			//и проверяем, является ли каждый символ цифрой и на той ли он позиции
			if((!str[j].isDigit()) && str.length()>j)
			{
				DigitalF=false;//если хотя бы один символ не цифра, то возвращаем ложь
			}
		}
	}
		return DigitalF;//возвращаем флаг
}

/*Функция проверки ввода букв ПОСЛЕ пробела:
*\param [in] str - строка, содержащая номинал
*\param [in]   i - индекс после первого пробела
*\return-LetterF - флаг, показывающий, введены ли только буквы после пробела
*/
bool Letterr(QString str,int i)
{
	i = 1+ Sydia(str);//находим индекс после первого пробела
	int j;//индекс символа строки
	bool LetterF=true;//флаг, показывающий, введены ли только буквы после пробела
	//Если позиция начинается со второго индекса,
	if(i>1)
	{
		for(j=i;j<30;j++)//то пробегаем стороку от позиции и до конца строки
		{
			//и проверяем, является ли каждый символ буквой и на той ли он позиции
			if((!str[j].isLetter()) && str.length()>j)
			{
				LetterF=false;//если хотя бы один символ не буква, то возвращаем ложь
			}
		}
	}
	//иначе если пробел еще не введен,
	else if(i==0)
	{
		return LetterF;//возвращаем правду
	}
	return LetterF;//возвращаем флаг
}

QValidator::State NominalValid::validate( QString & input, int & pos ) const
{
	//Если в строке вбольше одиного пробела или первый символ не цифра или цифры стоят не до пробела
	if(input.count(' ')>1  ||(!input[0].isDigit()&& input.length()>0) || !Digitall(input,Sydia(input)) || 
		!Letterr(input,Sydia(input))) //или буквы стоят не после пробела,
	{
		return QValidator::Invalid;//то запрещаем ввод в данной позиции
	}
	//Если же формат не соблюден, но можно изменить строку номинала так, чтобы номинал соответствовал формату
	//путем удаления, замены или вставки символа,
	return QValidator::Intermediate;////то возвращаем Intermediate
}
